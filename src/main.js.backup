document.querySelector('#record').addEventListener('click', onRecord);

const inProduction = true; // hide video and tmp canvas
const channel = 'r'; // red only, green='g' and blue='b' channels can be added

let video, c_tmp, ctx_tmp; // video from rear-facing-camera and tmp canvas
let frameCount = 0; // count number of video frames processed 
let delay = 0; // delay = 100; should give us 10 fps, estimated around 7
let numOfQualityFrames = 0; // TODO: count the number of quality frames
let xMeanArr = [];
let xMean = 0;
let initTime;
let isSignal = 0;
let acFrame = 0.008; // start with dummy flat signal
let acWindow = 0.008;

let nFrame = 0;
const WINDOW_LENGTH = 300; // 300 frames = 5s @ 60 FPS
let acdc = new Float32Array(WINDOW_LENGTH).fill(0.5);
let ac = new Float32Array(WINDOW_LENGTH).fill(0.5);

// Signal quality metrics
let snr_dB = 0;
let perfusionIndex = 0;
let signalStability = 1.0;
let qualityStatus = "Initializing";
let guidanceMessage = "Press Measure to start";
let heartRate = 0; // BPM from FFT peak
let ibi = 0; // Inter-beat interval in ms
let previousVariance = 0;

// draw the signal data as it comes
let lineArr = [];
const MAX_LENGTH = 100;
const DURATION = 100;
let chart = realTimeLineChart();

let constraintsObj = {
  audio: false,
  video: {
    maxWidth: 1280,
    maxHeight: 720,
    frameRate: { ideal: 60 },
    facingMode: 'environment' // rear-facing-camera
  }
};

function setWH() {
  let [w, h] = [video.videoWidth, video.videoHeight];
  document.getElementById('delay').innerHTML = `Frame compute delay: ${delay}`;
  document.getElementById('resolution').innerHTML = `Video resolution: ${w} x ${h}`;
  c_tmp.setAttribute('width', w);
  c_tmp.setAttribute('height', h);
}

function init() {
  c_tmp = document.getElementById('output-canvas');
  // Always hide canvas (only used for processing, not display)
  c_tmp.style.display = 'none';
  ctx_tmp = c_tmp.getContext('2d');
}

function computeFrame() {
  if (nFrame > DURATION) {
    ctx_tmp.drawImage(video,
      0, 0, video.videoWidth, video.videoHeight);
    let frame = ctx_tmp.getImageData(
      0, 0, video.videoWidth, video.videoHeight);

    // process each frame
    const count = frame.data.length / 4;
    let rgbRed = 0;
    for (let i = 0; i < count; i++) {
      rgbRed += frame.data[i * 4];
    }
    // invert to plot the PPG signal
    xMean = 1 - rgbRed / (count * 255);

    let xMeanData = {
      time: (new Date() - initTime) / 1000,
      x: xMean
    };

    acdc[nFrame % WINDOW_LENGTH] = xMean;

    // TODO: calculate AC from AC-DC only each WINDOW_LENGTH time:
    if (nFrame % WINDOW_LENGTH == 0) {
      // console.log(`nFrame = ${nFrame}`);
      // console.log(`ac = ${acdc}`);
      // console.log(`ac-detrended = ${detrend(acdc)}`);
      document.getElementById('signal-window').innerHTML = `nWindow: ${nFrame / WINDOW_LENGTH}`;
      if ((nFrame / 100) % 2 == 0) {
        isSignal = 1;
        const detrendedArray = detrend(acdc);
        ac = new Float32Array(detrendedArray);
        acWindow = windowMean(ac);

        // Calculate signal quality metrics after detrending
        updateSignalQuality();
      } else {
        ac = new Float32Array(WINDOW_LENGTH).fill(acWindow);
        isSignal = 0;
      }
    }

    acFrame = ac[nFrame % WINDOW_LENGTH];

    xMeanArr.push(xMeanData);

    // Lazy update non-critical UI (every 10 frames)
    if (frameCount % 10 === 0) {
      document.getElementById('frame-time').innerHTML = `Frame time: ${xMeanData.time.toFixed(2)}`;
      document.getElementById('video-time').innerHTML = `Video time: ${(video.currentTime.toFixed(2))}`;
      document.getElementById('signal').innerHTML = `X: ${xMeanData.x}`;

      const fps = (frameCount / video.currentTime).toFixed(3);
      document.getElementById('frame-fps').innerHTML = `Frame count: ${frameCount}, FPS: ${fps}`;
    }

    frameCount++;
    ctx_tmp.putImageData(frame, 0, 0);
  }
  nFrame += 1;
  requestAnimationFrame(computeFrame); // continue with requestAnimationFrame
}

function windowMean(y) {
  const n = y.length;
  let sum = 0;
  for (let i = 0; i < n; i++) {
    sum += y[i]
  }

  return sum / n;
}

function detrend(y) {
  const n = y.length;
  let x = [];
  for (let i = 0; i <= n; i++) {
    x.push(i);
  }

  let sx = 0;
  let sy = 0;
  let sxy = 0;
  let sxx = 0;
  for (let i = 0; i < n; i++) {
    sx += x[i];
    sy += y[i];
    sxy += x[i] * y[i];
    sxx += x[i] * x[i];
  }
  const mx = sx / n;
  const my = sy / n;
  const xx = n * sxx - sx * sx;
  const xy = n * sxy - sx * sy;
  const slope = xy / xx;
  const intercept = my - slope * mx;

  detrended = [];
  for (let i = 0; i < n; i++) {
    detrended.push(y[i] - (intercept + slope * i));
  }

  return detrended;
}

function calculateSNR(detrendedSignal) {
  const n = detrendedSignal.length;

  // Pad to next power of 2 for FFT (256 >= 300)
  const fftSize = 256;
  const paddedSignal = new Float32Array(fftSize);
  for (let i = 0; i < Math.min(n, fftSize); i++) {
    paddedSignal[i] = detrendedSignal[i];
  }

  // Compute FFT using FFT.js library
  const fft = new FFT(fftSize);
  const out = fft.createComplexArray();
  const input = fft.toComplexArray(paddedSignal);
  fft.transform(out, input);

  // Calculate Power Spectral Density (magnitude squared)
  const psd = new Float32Array(fftSize / 2);
  for (let i = 0; i < fftSize / 2; i++) {
    const real = out[2 * i];
    const imag = out[2 * i + 1];
    psd[i] = real * real + imag * imag;
  }

  // Define frequency bands
  const sampleRate = 60; // 60 FPS
  const freqResolution = sampleRate / fftSize; // 60/256 = 0.234 Hz

  // Cardiac signal band: 0.75-4.0 Hz (45-240 BPM)
  const signalBandIdx = {
    low: Math.floor(0.75 / freqResolution),
    high: Math.ceil(4.0 / freqResolution)
  };

  // Calculate power in signal and total bands
  let signalPower = 0;
  let totalPower = 0;
  let maxPower = 0;
  let peakIdx = 0;

  for (let i = 1; i < psd.length; i++) { // Skip DC component (i=0)
    totalPower += psd[i];

    if (i >= signalBandIdx.low && i <= signalBandIdx.high) {
      signalPower += psd[i];

      // Track peak for heart rate estimation
      if (psd[i] > maxPower) {
        maxPower = psd[i];
        peakIdx = i;
      }
    }
  }

  // Calculate noise power
  const noisePower = totalPower - signalPower;

  // Calculate SNR in dB (add small epsilon to avoid log(0))
  const epsilon = 1e-10;
  const snr = 10 * Math.log10((signalPower + epsilon) / (noisePower + epsilon));

  // Extract heart rate from peak frequency (Hz to BPM)
  const hr = (peakIdx * freqResolution) * 60;

  return { snr_dB: snr, heartRate: hr };
}

function calculatePerfusionIndex(rawSignal, detrendedSignal) {
  const n = rawSignal.length;

  // DC component (mean of raw signal)
  let sum = 0;
  for (let i = 0; i < n; i++) {
    sum += rawSignal[i];
  }
  const dc = sum / n;

  // AC component (standard deviation of detrended signal)
  let variance = 0;
  for (let i = 0; i < n; i++) {
    variance += detrendedSignal[i] * detrendedSignal[i];
  }
  variance = variance / n;
  const ac = Math.sqrt(variance);

  // Perfusion Index as percentage
  const pi = (ac / (dc + 1e-10)) * 100;

  return { pi, variance };
}

function generateGuidance(snr, pi, stability) {
  if (snr < 0) {
    if (pi < 0.3) {
      return "Cover camera completely with finger";
    }
    return "Adjust finger placement";
  }

  if (snr >= 0 && snr < 5) {
    if (pi < 1.0) {
      return "Press finger more firmly";
    }
    if (pi > 15) {
      return "Reduce finger pressure slightly";
    }
    if (stability < 0.5) {
      return "Hold finger still";
    }
    return "Adjusting... hold steady";
  }

  if (snr >= 5 && snr < 10) {
    return "Good signal - hold steady";
  }

  // snr >= 10
  return "Excellent signal!";
}

function getQualityStatus(snr) {
  if (snr >= 10) return "Excellent";
  if (snr >= 5) return "Good";
  if (snr >= 0) return "Fair";
  return "Poor";
}

function updateSignalQuality() {
  // Calculate SNR and heart rate from detrended signal
  const snrResult = calculateSNR(ac);
  snr_dB = snrResult.snr_dB;
  heartRate = snrResult.heartRate;

  // Calculate IBI (Inter-Beat Interval) from heart rate
  if (heartRate > 0 && heartRate < 300) {
    ibi = Math.round(60000 / heartRate); // Convert BPM to milliseconds
  } else {
    ibi = 0;
  }

  // Calculate Perfusion Index
  const piResult = calculatePerfusionIndex(acdc, ac);
  perfusionIndex = piResult.pi;

  // Calculate signal stability (comparing variance across windows)
  if (previousVariance > 0) {
    const varianceRatio = Math.min(piResult.variance, previousVariance) /
                         (Math.max(piResult.variance, previousVariance) + 1e-10);
    signalStability = varianceRatio;
  }
  previousVariance = piResult.variance;

  // Update quality status
  qualityStatus = getQualityStatus(snr_dB);

  // Generate guidance message
  guidanceMessage = generateGuidance(snr_dB, perfusionIndex, signalStability);

  // Update quality frame counter
  if (snr_dB >= 5) {
    numOfQualityFrames += WINDOW_LENGTH;
  }

  // Update DOM elements
  updateQualityDisplay();
}

function updateQualityDisplay() {
  // Update metric values
  document.getElementById('snr-value').innerHTML = snr_dB.toFixed(1) + ' dB';
  document.getElementById('pi-value').innerHTML = perfusionIndex.toFixed(1) + '%';
  document.getElementById('hr-value').innerHTML = Math.round(heartRate) + ' BPM';
  document.getElementById('ibi-value').innerHTML = ibi > 0 ? ibi + ' ms' : '-- ms';

  // Update quality status with appropriate class
  const statusElement = document.getElementById('quality-status');
  statusElement.innerHTML = qualityStatus;

  // Remove all status classes
  statusElement.classList.remove('excellent', 'good', 'fair', 'poor', 'initializing');

  // Add appropriate class based on status
  statusElement.classList.add(qualityStatus.toLowerCase());

  // Update finger guide circle color based on signal quality
  const guideCircle = document.querySelector('.guide-circle');
  if (guideCircle) {
    guideCircle.classList.remove('excellent', 'good', 'fair', 'poor');
    guideCircle.classList.add(qualityStatus.toLowerCase());
  }

  // Update guidance message
  document.getElementById('guidance-message').innerHTML = guidanceMessage;
}

function onRecord() {
  this.disabled = true;

  // Update initial guidance message
  guidanceMessage = "Starting camera...";
  document.getElementById('guidance-message').innerHTML = guidanceMessage;

  navigator.mediaDevices.getUserMedia(constraintsObj)
    .then(function(mediaStreamObj) {

      // we must turn on the LED / torch
      const track = mediaStreamObj.getVideoTracks()[0];
      const imageCapture = new ImageCapture(track)
      const photoCapabilities = imageCapture.getPhotoCapabilities()
        .then(() => {
          track.applyConstraints({
              advanced: [{ torch: true }]
            })
            .catch(err => console.log('No torch', err));
        })
        .catch(err => console.log('No torch', err));

      video = document.getElementById('video');
      // Video element is now shown as camera preview (styled by CSS)

      if ("srcObject" in video) {
        video.srcObject = mediaStreamObj;
      } else {
        // for older versions of browsers
        video.src = window.URL.createObjectURL(mediaStreamObj);
      }

      video.onloadedmetadata = function(ev) {
        video.play();
      };

      init();
      video.addEventListener('play', setWH);
      video.addEventListener('play', computeFrame);
      video.addEventListener('play', drawLineChart);

      video.onpause = function() {
        console.log('paused');
      };
    })
    .catch(error => console.log(error));
}

function pauseVideo() {
  video.pause();
  video.currentTime = 0;
}

function seedData() {
  let now = new Date();

  for (let i = 0; i < MAX_LENGTH; ++i) {
    lineArr.push({
      time: new Date(now.getTime() - initTime - ((MAX_LENGTH - i) * DURATION)),
      x: 0.5,
      signal: isSignal
    });
  }
}

function updateData() {
  let now = new Date();

  let lineData = {
    time: now - initTime,
    x: acFrame,
    signal: isSignal
  };
  lineArr.push(lineData);

  // if (lineArr.length > 1) {
  lineArr.shift();
  // }
  d3.select("#chart").datum(lineArr).call(chart);
}

function resize() {
  if (d3.select("#chart svg").empty()) {
    return;
  }
  chart.width(+d3.select("#chart").style("width").replace(/(px)/g, ""));
  d3.select("#chart").call(chart);
}

function drawLineChart() {
  initTime = new Date();

  seedData();
  window.setInterval(updateData, 100);
  d3.select("#chart").datum(lineArr).call(chart);
  d3.select(window).on('resize', resize);
}